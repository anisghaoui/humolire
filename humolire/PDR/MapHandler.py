import json
import os.path as osp
from typing import List, Callable

import numpy as np

from .Particle import Particle


class Node:
    """
    The Node is a point (x,y) in any pixels or meters. The method :meth:`MapHandler.Node.scale_by` will multiply the
    x and y values by a scale to obtain values in meters. 2 Nodes are necessary to define a :class:`MapHandler.Wall`.
    """

    def __init__(self, id: int, layer: int, x: float, y: float):
        self.id = id
        self.layer = layer
        self.x = x
        self.y = y

    def scale_by(self, scale: float):
        self.x *= scale
        self.y *= scale
        return self

    def __str__(self):
        s = f'\tid = {self.id}\n'
        s += f'\tlayer = {self.layer}\n'
        s += f'\tx = {self.x}\n'
        s += f'\ty = {self.y}'
        return s


class Wall:
    """
    A Wall is defined by 2 :class:`MapHandler.Node`.
    """

    def __init__(self, id, node0: Node, node1: Node, layer=None):
        self.id = id
        self.layer = node0.layer if layer is None else layer
        self.node0 = node0
        self.node1 = node1

    def __str__(self):
        s = f'id = {self.id}\n'
        s += f'layer = {self.layer}\n'
        s += f'node0 =\n {self.node0}\n'
        s += f'node1 =\n {self.node1}\n'
        return s


class MapHandler:
    """
    This class is the description of the mathematical object that represents a floor-map and how it is used.

    Parameters
    ----------
    path : str
        <path-to-file>.json. the file contains information generated by :py:class:`coreEditor`
    build_grid : bool
        Indicates if a likelihood :class:`MapHandler.MapGrid` should be built from the map with each cell.
    kwargs : dict, optional
        optional key-worded arguments to override the default ones.
        kwargs are always propagated into functions that needs them.

        here is a list # TODO list kwargs



    .. warning::
        be aware of the scale and resolution
    """

    def __init__(self, path: str, build_grid: bool = True, **kwargs):

        path = osp.join(path)
        _dir = osp.dirname(path)
        filename = osp.basename(path)
        self.filename = filename
        map_data = json.load(open(path))

        self.map_file_names = map_data["map_file_names"]

        # depends on the resolution and plan scale
        self.scale = map_data["scale"]

        # load links
        links = map_data["links"]
        self.walls = [Wall(link["id"],
                           Node(**link["node0"]).scale_by(self.scale),
                           Node(**link["node1"]).scale_by(self.scale)
                           ) for link in links]

        # the y axis during run time is inverted because opencv has a row,col representation
        # (image processing standard).
        self.width = map_data["x_range"][1] * self.scale
        self.height = map_data["y_range"][1] * self.scale
        for wall in self.walls:
            wall.node0.y = self.height - wall.node0.y
            wall.node1.y = self.height - wall.node1.y

        self.y_range = map_data["y_range"]
        self.y_range[1] *= self.scale
        self.y_range[0] *= self.scale  # should always be 0
        self.x_range = map_data["x_range"]
        self.x_range[1] *= self.scale
        self.x_range[0] *= self.scale

        # build the grid of the floor
        if build_grid:
            self.grid = MapGrid(map_height=self.y_range[1], map_width=self.x_range[1], walls=self.walls, **kwargs)
        else:
            self.grid = None

    def filter(self, previous_particles: List[Particle], particles: List[Particle]):
        """
            Filters each particle that went from previous particle to particle and crossed a :class:`MapHandler.Wall`.

        Parameters
        ----------
        previous_particles : List[Particle]
            Previous state of particle
        particles : List[Particle]
            New state of particle

        Returns
        -------
        valid_particles : List[Particle]
            particles that are valid because they didn't cross a wall or went out of the map
        rejected_particles :
            particles aren't valid
        """
        # check if a particle moved across a wall after being updated
        valid_particles = []
        rejected_particles = []
        for prev_particle, particle in zip(previous_particles, particles):
            if self.is_inside_map(particle.position) \
                    and not self.is_wall_crossing(prev_particle.position, particle.position):
                valid_particles.append(particle)  # these have succeeded the test
            else:
                rejected_particles.append(prev_particle)  # these have failed it and must retake it
        return valid_particles, rejected_particles

    def is_wall_crossing(self, prev_pos: Particle.position, position: Particle.position) -> bool:
        """
        checks if a line formed bu position and prev_pos crossed any wall.

        Parameters
        ----------
        prev_pos : Particle.position
            represents the previous position of a particle. Can be any object with 2 attributes `x` and `y`
        position : Particle.position
            represents the previous position of a particle. Can be any object with 2 attributes `x` and `y`

        Returns
        -------
        wall_crossed : bool
            True if a wall is crossed. Else, False.
        """
        walls = self.walls
        for wall in walls:
            wall_crossed = self.intersect(prev_pos, position, wall)
            if wall_crossed:
                return wall_crossed
        return False

    def is_inside_map(self, position):
        if self.x_range[0] < position.x < self.x_range[1] \
                and self.y_range[0] < position.y < self.y_range[1]:
            return True
        return False

    def get_likelihood_from_grid(self, index_y: float, index_x: float) -> float:
        if self.grid is None:
            return 1
        return self.grid[index_y, index_x]

    @staticmethod
    def intersect(prev_pos, pos, wall: Wall):
        # There are so many ways to check if 2 line segments intersect:
        # check this: https://izziswift.com/how-can-i-check-if-two-segments-intersect/
        def ccw(A, B, C):
            return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x)

        def intersect(A, B, C, D):
            return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)

        return intersect(prev_pos, pos, wall.node0, wall.node1)


class MapGrid:
    def __init__(self, map_height: float, map_width: float, walls: List[Wall], reload_cache=False, path_to_grid=None,
                 cell_size: float = 10.0, distance_to_proba: Callable = None, k_adjacency: int = 4, **kwargs):
        # map size in meters, cell size is centimeters
        self.height = np.ceil(map_height * 100 / cell_size).astype("int")
        self.width = np.ceil(map_width * 100 / cell_size).astype("int")
        self.cell_size = cell_size

        # the grid is a matrix h x w which is opposite
        self.grid = np.ones((self.height, self.width), dtype="float32")
        self.distance_to_likelihood = self.linearized_sigmoid if distance_to_proba is None else distance_to_proba

        folder_grid = osp.dirname(osp.abspath(__file__))
        path_to_grid = osp.join(folder_grid, '../grid.npy') if path_to_grid is None else path_to_grid

        if reload_cache or not osp.isfile(path_to_grid):
            print("recreating the map grid from map data")
            self.add_walls(walls)
            self.build_distance_map(k_adjacency=k_adjacency, **kwargs)
            np.save(path_to_grid, self.grid)
        else:
            print("Map grid is already cashed...")
            self.grid = np.load(path_to_grid)

    def add_walls(self, walls: List[Wall]):
        for wall in walls:
            i, j = wall.node0.x, wall.node0.y
            k, l = wall.node1.x, wall.node1.y

            # indices are in meters
            def to_cell(index):
                return int(index * 100 / self.cell_size)  # 100 is for m -> cm

            i = to_cell(i)  # x_1
            j = to_cell(j)  # y_1
            k = to_cell(k)  # x_2
            l = to_cell(l)  # y_2

            # count how many cells the wall will occupy on y and x
            n_x_case = np.ceil(np.abs(i - k)).astype("int")
            n_y_case = np.ceil(np.abs(l - j)).astype("int")

            # generate an array for those cell
            x = np.linspace(i, k, n_x_case + 1).astype("int")
            y = np.linspace(j, l, n_y_case + 1).astype("int")

            # To set all the wall cells to 0, we need to have an array that is exactly of shape N,N
            if y.size > x.size:
                x = np.repeat(x, np.ceil(y.size / x.size))
                x = x[:y.size]  # size is shape[0] for 1D arrays
            elif y.size < x.size:
                y = np.repeat(y, np.ceil(x.size / y.size))
                y = y[:x.size]
            assert x.size == y.size, f"{x.size = }, {y.size = }"

            # since the matrix-image is arranged as a graph, meaning the origin is at the bottom left corner,
            # y is vertical and x is horizontal
            self.grid[y, x] = 0

    def build_distance_map(self, k_adjacency: int = 4, **kwargs):
        # page 17/33 of https://nicolaslerme.fr/my_docs/452/cours3_visu.pdf , in french
        assert k_adjacency == 8 or k_adjacency == 4, "k_adjacency is either 8 or 4"
        self.grid[self.grid != 0] = np.inf  # no wall = inf
        for i in range(self.height):
            for j in range(self.width):
                NW = self.grid[i - 1, j - 1] if self.width > j - 1 >= 0 and self.height > i - 1 >= 0 else np.inf
                N = self.grid[i - 1, j] if self.width > j >= 0 and self.height > i - 1 >= 0 else np.inf
                NE = self.grid[i - 1, j + 1] if self.width > j + 1 >= 0 and self.height > i - 1 >= 0 else np.inf
                W = self.grid[i, j - 1] if self.width > j - 1 >= 0 and self.height > i >= 0 else np.inf

                # for 8-adjacency compare 5 points, for 4-adjacency compare 3 points
                if k_adjacency == 8:
                    self.grid[i, j] = min(self.grid[i, j], NW + 1, N + 1, NE + 1, W + 1)
                elif k_adjacency == 4:
                    self.grid[i, j] = min(self.grid[i, j], N + 1, W + 1)
                else:
                    raise ValueError("k_adjacency can only be 4 or 8")

        for i in range(self.height - 1, -1, -1):
            for j in range(self.width - 1, -1, -1):
                SW = self.grid[i + 1, j - 1] if self.width > j - 1 >= 0 and self.height > i + 1 >= 0 else np.inf
                S = self.grid[i + 1, j] if self.width > j >= 0 and self.height > i + 1 >= 0 else np.inf
                SE = self.grid[i + 1, j + 1] if self.width > j + 1 >= 0 and self.height > i + 1 >= 0 else np.inf
                E = self.grid[i, j + 1] if self.width > j + 1 >= 0 and self.height > i >= 0 else np.inf

                if k_adjacency == 8:
                    self.grid[i, j] = min(self.grid[i, j], SW + 1, S + 1, SE + 1, E + 1)
                elif k_adjacency == 4:
                    self.grid[i, j] = min(self.grid[i, j], S + 1, E + 1)
                else:
                    raise ValueError("k_adjacency can only be 4 or 8")

        for i in range(self.height):
            for j in range(self.width):
                a = self.distance_to_likelihood(self.grid[i, j], **kwargs)
                self.grid[i, j] = a

    @staticmethod
    def linearized_sigmoid(distance, min_wall_range: int = 8, max_wall_range: int = 10, **kwargs) -> float:
        """
            return 1 if distance > max_wall_range else distance / max_wall_range
        """
        assert min_wall_range > -1 and max_wall_range >= 0, "This sigmoid is only defined for positive distances"
        # approximating a sigmoid:
        if distance < min_wall_range:
            return 0.0
        elif min_wall_range <= distance < max_wall_range:
            return (distance - min_wall_range) / max(max_wall_range - min_wall_range, 1)
        else:
            return 1.0

    def __getitem__(self, indices):
        assert len(indices) == 2, "Only 2 indices allowed: x and y"
        y = int(indices[0] * 100 / self.cell_size)
        x = int(indices[1] * 100 / self.cell_size)
        if self.width > x >= 0 and self.height > y >= 0:
            return self.grid[y, x]
        return 0.0

    # the old way to build the grid
    # def _slow_build_distance_map(self):
    #     # used only for educational purpose
    #     for i in tqdm(range(self.height)):
    #         for j in range(self.width):
    #             if self.grid[i, j] != 0:
    #                 wall_cell, distance = self.closest_wall(i, j)
    #                 # update the neighbourhood probabilities
    #                 for k in range(-distance, distance + 1):
    #                     for l in range(-distance, distance + 1):
    #                         row = i + k
    #                         col = j + l
    #                         if self.width > col >= 0 and self.height > row >= 0:
    #                             d = sqrt(abs(row - wall_cell[0]), abs(col - wall_cell[1]))  # 8-adjacency
    #                             p = self.distance_to_likelihood(d)
    #                             self.grid[row, col] = min(p, self.grid[row, col])
    #
    # def closest_wall(self, i, j):
    #     wall_found = False
    #     search_range = 1
    #     wall_row = np.inf
    #     wall_col = np.inf
    #     distance = np.inf
    #     while not wall_found:
    #         for k in [-search_range, search_range]:
    #             for l in range(-search_range, search_range + 1):
    #                 row = i + k
    #                 col = j + l
    #                 if self.width > col >= 0 and self.height > row >= 0:
    #                     if self.grid[row, col] == 0:  # cell is a wall
    #                         # find if the current wall is closer to the cell than the previous, in 8 adjacency
    #                         if max(abs(row - i), abs(col - j)) < max(abs(wall_row - i), abs(wall_col - j)):
    #                             distance = max(abs(row - i), abs(col - j))
    #                             wall_found = True
    #                             wall_row = row
    #                             wall_col = col
    #         for l in [-search_range, search_range]:
    #             for k in range(-search_range, search_range + 1):
    #                 row = i + k
    #                 col = j + l
    #                 if self.width > col >= 0 and self.height > row >= 0:
    #                     if self.grid[row, col] == 0:
    #                         # find if the current wall is closer to the cell than the previous, in 8 adjacency
    #                         if max(abs(row - i), abs(col - j)) < max(abs(wall_row - i), abs(wall_col - j)):
    #                             distance = max(abs(row - i), abs(col - j))
    #                             wall_found = True
    #                             wall_row = row
    #                             wall_col = col
    #         search_range += 1
    #     else:  # the wall was found decrement the last increment
    #         search_range -= 1
    #     assert wall_col != np.inf
    #     assert wall_row != np.inf
    #     assert distance != np.inf
    #     return (wall_row, wall_col), distance

    def __str__(self):
        s = "Map Matcher:\n"
        for k, v in self.__dict__.items():
            if k not in ["walls"]:
                s += f'{k} = {v}\n'
            else:
                for link in v:
                    s += f"{link}\n"
        return s
